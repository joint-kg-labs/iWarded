package org.vadalog.iwarded.generator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ThreadLocalRandom;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.vadalog.iwarded.model.Atom;
import org.vadalog.iwarded.model.Literal;
import org.vadalog.iwarded.model.Model;
import org.vadalog.iwarded.model.Rule;
import org.vadalog.iwarded.model.annotations.OutputAnnotation;



/**
 * This class coordinates the generation of the model in iWarded
 * 
 * The generic program consists of:
 * *Comment section - Original parameters*:
	documents the value of the input parameters as well as internal parameters generated by iWarded 
	(e.g., the average number of chase steps and the number of steps for each output atom, respectively).
 *
 * *Comment section - Adapted parameters*:
	documents the adjustments applied by iWarded to the input parameters to generate a consistent set of rules.
 *
 * *Annotation section*:
	the set of ```@output```, ```@input```, ```@bind``` and ```@mapping``` annotations, with reference to the output atoms, 
	the input atoms, the data sources' location and the arguments mapping, respectively.
 *
 * *Root rule*:
	the first rule of the set, by convention it is a linear harmless rule.
 *
 * *Input-Output sequence*:
	a set of linear and join rules, with various characteristics based on the input parameters.
 *
 * *Recursive sequences*:
	a set of rules part of a recursion.
 *
 * *Recursive closure sequence*:
	a set of linear and join rules, each introducing a recursion and thus a cycle in the predicate graph.
 *
 * *Program completion sequence*:
	a set of extra rules needed to globally satisfy the parameters, e.g., the number of selection conditions, in the form of expressions, in our example.
 *
 * *Output completion sequence*:
	a set of linear rules, one for each input-output sequence; the rule head is the output atom and the body atom is connected to the head of the rule closing the sequence.
 * 
 * @author tbaldazzi
 * 
 * Copyright (C) 2021  authors: Teodoro Baldazzi, Luigi Bellomarini, Emanuel Sallinger
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see https://www.gnu.org/licenses/gpl-3.0.html
 */
public class ModelGenerator {


	private Logger log = LoggerFactory.getLogger(ModelGenerator.class);

	/*static variables*/
	static ModelGenerator modelInstance;
	private final static String linearRule = "linear";
	private final static String joinRule = "join";
	final static String joinhhW = "harmless-harmless-ward";
	final static String joinhhNW = "harmless-harmless-noWard";
	final static String joinhH = "harmless-harmful";
	final static String joinHH = "harmful-harmful";

	/*variables which reference other classes in iWarded*/
	Model resultModel;
	CompatibilityAdapter adapter;
	DataGenerator data;
	ConditionGenerator conditions;
	FileGenerator file;

	/*input variables*/
	Integer numberOfInputAtoms;
	Integer numberOfOutputAtoms;
	Integer averageVarsInAtom;
	Float varianceVarsInAtom;
	Integer numberOfExistentialRules;
	Integer averageEVarsInRule;
	Float varianceEVarsInRule;
	Integer numberOfDangerousRules;
	Integer numberOfLinearRules;
	Integer numberOfHarmlessHarmlessJoinsWithWard;
	Integer numberOfHarmlessHarmlessJoinsWithoutWard;
	Integer numberOfHarmlessHarmfulJoins;
	Integer numberOfHarmfulHarmfulJoins;	
	Integer averageChaseSteps;
	Integer numberOfLinearRecursions;
	Integer numberOfLeftJoinRecursions;
	Integer numberOfRightJoinRecursions;
	Integer numberOfNonLinearJoinRecursions;
	Integer averageRecursionLength;
	Integer numberOfSelectionConditions;
	Integer averageSelectivity;
	Integer numberOfRecordsCSV;
	boolean isGuarded;
	String programName;

	/*variables for chase steps*/
	Rule root;
	Atom lastAtomInHead;
	Map<String,Integer> cSteps = new HashMap<>();
	Map<String,Atom> cLast = new HashMap<>();
	Map<String,Integer> idbNumVariables = new HashMap<>();	
	List<String> inputAtomNames;
	List<String> outputAtomNames;
	Set<Literal> inputLiterals = new HashSet<>();
	Map<String,Integer> inputLiteralNamesArguments = new HashMap<>();
	Integer idbInstance = 1;
	Integer harmlessInstance = 1;
	Integer harmfulInstance = 1;

	/*variables for join rules */
	String typeOfJoin;
	Integer numberOfJoinRules;

	/*variables for existentials and dangerous rules*/
	Set<String> affectedAtomNames = new HashSet<>();
	Map<String,Integer> numAffectedPositionsPerAtom = new HashMap<>();
	Atom firstExistentialHead;

	/*variables for recursive cycles*/
	Literal literalDirectRec;
	Map<String,Integer> rLength = new HashMap<>();
	Map<String,Atom> rLast = new HashMap<>();
	List<String> recursionNames = new ArrayList<>();
	List<String> indirectRecursionName = new ArrayList<>();;
	List<String> directRecursionName = new ArrayList<>();;
	List<String> recLinNames = new ArrayList<>();
	List<String> recLeftJoinNames = new ArrayList<>();
	List<String> recRightJoinNames = new ArrayList<>();
	List<String> recNonLinearJoinNames = new ArrayList<>();
	Map<String,Atom> bodyRuleForIndNonLinRecJoinRightAtom = new HashMap<>();
	Map<String,Atom> recNonLinIndJoinRightAtom = new HashMap<>();

	/*variables for selection conditions*/
	Map<String,Integer> conditionForRule = new HashMap<>();
	Map<String,Integer> selectivityForRule = new HashMap<>();

	/*variables for guardedness*/
	String inputAtomNameForGuarded;



	/**
	 * Constructor for ModelGenerator 
	 */
	private ModelGenerator(){
		this.resultModel = new Model();
	}



	/**
	 * It gets instance of ModelGenerator (pattern Singleton application)
	 * 
	 * @return instance
	 */
	public static ModelGenerator getModelInstance(){
		if(modelInstance==null)
			modelInstance = new ModelGenerator();
		return modelInstance;
	}



	/**
	 * It updates idb counter
	 */
	public void updateIdbInstance(){
		this.idbInstance = this.idbInstance + 1;
	}



	/**
	 * It updates harmless counter
	 */
	public void updateHarmlessInstance(){
		this.harmlessInstance = this.harmlessInstance + 1;
	}



	/**
	 * It updates harmful counter
	 */
	public void updateHarmfulInstance(){
		this.harmfulInstance = this.harmfulInstance + 1;
	}



	/**
	 * It randomly select the type of current rule
	 * 
	 * @return type of rule
	 */
	private String defineTypeOfRule() {
		List<String> typesOfRule = new ArrayList<>();
		/*if there are not remaining join rules, add linear rules*/
		if(this.numberOfLinearRules>0 || this.numberOfJoinRules<=0)
			typesOfRule.add(linearRule);
		if(this.numberOfJoinRules>0)
			typesOfRule.add(joinRule);

		int num = ThreadLocalRandom.current().nextInt(0, typesOfRule.size());
		String typeOfRule = typesOfRule.get(num);

		return typeOfRule;
	}



	/**
	 * It randomly select the type of current join, based on the head of the previous rule
	 * 
	 * @param previousHead
	 * @return type of join
	 */
	private String defineAndUpdateTypeOfJoin(Atom previousHead) {

		String typeOfJoin = null;

		List<String> typesOfJoin = new ArrayList<>(); 
		String previousHeadName = previousHead.getName();

		if(this.numberOfHarmlessHarmlessJoinsWithWard>0 && 
				(!this.affectedAtomNames.contains(previousHeadName) || 
						(this.affectedAtomNames.contains(previousHeadName) 
								&& previousHead.getArguments().size()>(this.numAffectedPositionsPerAtom.get(previousHeadName)+1))))
			typesOfJoin.add(joinhhW);
		if(this.numberOfHarmlessHarmlessJoinsWithoutWard>0 && 
				(!this.affectedAtomNames.contains(previousHeadName) || 
						(this.affectedAtomNames.contains(previousHeadName) 
								&& previousHead.getArguments().size()>(this.numAffectedPositionsPerAtom.get(previousHeadName)+1))))
			typesOfJoin.add(joinhhNW);
		if(this.numberOfHarmlessHarmfulJoins>0 && this.affectedAtomNames.contains(previousHeadName))
			typesOfJoin.add(joinhH);
		if(this.numberOfHarmfulHarmfulJoins>0 && this.affectedAtomNames.contains(previousHeadName))
			typesOfJoin.add(joinHH);

		try {
			int num = ThreadLocalRandom.current().nextInt(0, typesOfJoin.size());
			typeOfJoin = typesOfJoin.get(num);	
		}
		catch (Exception e) {
			/*if there are no other possible types of join, use an harmless without ward one*/
			typeOfJoin = joinhhNW;
		}

		/*update the chosen type of join*/
		if(typeOfJoin.equals(joinhhW))
			this.numberOfHarmlessHarmlessJoinsWithWard --;
		else
			if(typeOfJoin.equals(joinhhNW))
				this.numberOfHarmlessHarmlessJoinsWithoutWard --;
			else
				if(typeOfJoin.equals(joinhH))
					this.numberOfHarmlessHarmfulJoins --;
				else
					if(typeOfJoin.equals(joinHH))
						this.numberOfHarmfulHarmfulJoins --;

		return typeOfJoin;
	}



	/**
	 * It randomly chooses whether the current rule is dangerous
	 *
	 * @return whether rule is dangerous
	 */
	private boolean isDangerousRule() {
		int isDangerous = ThreadLocalRandom.current().nextInt(0, 1 + 1);
		if(isDangerous == 1)
			return false;
		else
			return true;
	}



	/**
	 * It randomly chooses whether the current rule is existential
	 *
	 * @return whether rule is existential
	 */
	private boolean isExistentialRule(){
		int isExistential = ThreadLocalRandom.current().nextInt(0, 1 + 1);
		if(isExistential == 0)
			return false;
		else
			return true;
	}



	/**
	 * It randomly chooses whether the current rule has selection conditions
	 *
	 * @return whether rule has conditions
	 */
	private boolean hasSelectionCondition() {
		int hasSelectionCondition = ThreadLocalRandom.current().nextInt(0, 1 + 1);
		if(hasSelectionCondition == 1 && this.numberOfSelectionConditions>0)
			return true;
		else
			return false;
	}



	/**
	 * It sets input parameters with input args and other instance variables
	 */
	public void setParameters(String[] args){
		this.numberOfInputAtoms = Integer.parseInt(args[0]);
		this.numberOfOutputAtoms = Integer.parseInt(args[1]);
		this.averageVarsInAtom = Integer.parseInt(args[2]);
		this.varianceVarsInAtom = Float.parseFloat(args[3]);
		this.numberOfExistentialRules = Integer.parseInt(args[4]);
		this.averageEVarsInRule = Integer.parseInt(args[5]);
		this.varianceEVarsInRule = Float.parseFloat(args[6]);
		this.numberOfDangerousRules = Integer.parseInt(args[7]);
		this.numberOfLinearRules = Integer.parseInt(args[8]);
		this.numberOfHarmlessHarmlessJoinsWithWard = Integer.parseInt(args[9]);
		this.numberOfHarmlessHarmlessJoinsWithoutWard = Integer.parseInt(args[10]);
		this.numberOfHarmlessHarmfulJoins = Integer.parseInt(args[11]);
		this.numberOfHarmfulHarmfulJoins = Integer.parseInt(args[12]);		
		this.averageChaseSteps = Integer.parseInt(args[13]);
		this.numberOfLinearRecursions = Integer.parseInt(args[14]);
		this.numberOfLeftJoinRecursions = Integer.parseInt(args[15]);
		this.numberOfRightJoinRecursions = Integer.parseInt(args[16]);
		this.numberOfNonLinearJoinRecursions = Integer.parseInt(args[17]);
		this.averageRecursionLength = Integer.parseInt(args[18]);
		this.numberOfSelectionConditions = Integer.parseInt(args[19]);
		this.averageSelectivity = Integer.parseInt(args[20]);
		this.numberOfRecordsCSV = Integer.parseInt(args[21]);
		this.isGuarded = false;
		if(args[22].equals("true"))
			this.isGuarded = true;
		this.programName = args[23];

		this.data = new DataGenerator();
		this.adapter = new CompatibilityAdapter();
		this.file = new FileGenerator();
		this.conditions = new ConditionGenerator();
	}



	/**
	 * This is the main method to create the vada program
	 * @return The final model
	 */
	public Model createModel(String path) {

		log.info("BEGIN generation of vada program");

		List<String> modelComments = new ArrayList<>();

		/*initialize the adapter to check for parameters compatibility*/
		this.adapter.initializeParametersCompatibility();

		/*define names and attributes of atoms and rules for the vada program*/
		this.data.defineAtomsAndRules();

		/*add original parameters as comments*/
		modelComments.addAll(this.file.addOriginalProgramParametersToVadaFile());

		/*update the parameters for compatibility with the adapter*/
		this.adapter.updateParametersCompatibility();

		/*generate rules for input-output sequence*/
		this.generateRulesForChaseSteps();

		/*generate rules for recursive cycles*/
		this.generateRulesForRecursions();

		/*generate rules to complete remaining input requirements*/
		this.generateRulesForCompletion();

		/*generate rules to complete input-output sequences*/
		this.generateRulesForOutput();

		/*add updated parameters as comments*/
		modelComments.addAll(this.adapter.addAdaptedProgramParametersToVadaFile());

		/*set parameters as comments in the .vada file*/
		this.resultModel.setComments(modelComments);

		/*here we create the input and bind annotations and generate the input csv file*/
		this.file.createInputBindMappingAnnotations(this.numberOfRecordsCSV, this.resultModel, path);
		System.out.println("\n=====Vadalog Program successfully built=====\n");

		/*set instance to null to allow multiple generation in same session of iWarded*/
		ModelGenerator.modelInstance = null;

		log.info("END generation of vada program");

		return this.resultModel;

	}



	/**
	 * It generates rules for input-output sequence
	 */
	private void generateRulesForChaseSteps(){

		boolean isRoot = true;

		boolean chaseStepsFinished = false;

		if (log.isDebugEnabled()) log.debug("Generating rules for input-output sequence");
		System.out.println("\n=====Generating rules for input-output sequence=====");
		while(!chaseStepsFinished){
			Rule currentRule;

			/*define the BODY of the rule*/
			List<Literal> body = new ArrayList<>();

			/*define whether the rule is linear or join*/	
			String linearOrJoin = this.defineTypeOfRule();

			/*choose the type of join, if needed*/
			this.typeOfJoin = null;
			if(!isRoot && linearOrJoin.equals(ModelGenerator.joinRule))
				this.typeOfJoin = this.defineAndUpdateTypeOfJoin(lastAtomInHead);

			/*build body of current rule*/
			if(isRoot || linearOrJoin.equals(ModelGenerator.linearRule) || this.typeOfJoin==null) {
				LinearRuleGenerator l = new LinearRuleGenerator();
				body.add(l.createLinearBodyChaseSteps(this.lastAtomInHead,isRoot));
				this.numberOfLinearRules--;
			}
			else {
				JoinRuleGenerator j = new JoinRuleGenerator();
				body = j.createJoinBodyChaseSteps(this.lastAtomInHead,this.typeOfJoin,this.isGuarded);//,harmlessOrDangerous);
				this.numberOfJoinRules--;
			}


			/*define the HEAD of the rule*/
			Atom head;

			/*check whether the body is affected*/
			boolean isBodyAffected = this.affectedAtomNames.contains(body.get(0).getAtom().getName());

			boolean isDangerous = false;
			if(isBodyAffected){
				/*define whether the rule is dangerous, based on typeOfJoin*/
				if(this.typeOfJoin==null)	// linear rule
					isDangerous = this.isDangerousRule();
				else	// join rule
					if(this.typeOfJoin.equals(joinHH) || this.typeOfJoin.equals(joinhhNW))
						isDangerous = false;
					else
						if(this.typeOfJoin.equals(joinhhW))
							isDangerous = true;
						else // joinhH
							isDangerous = this.isDangerousRule();				

				if(isDangerous)
					this.numberOfDangerousRules--;
			}
			/*define whether the rule is existential*/
			boolean isExistential = false;
			if(this.numberOfExistentialRules>0 && !isDangerous && !isRoot){
				isExistential = this.isExistentialRule();
				if(isExistential)
					this.numberOfExistentialRules--;
			}

			/*build head of current rule*/
			RuleGenerator l = new LinearRuleGenerator();
			head = l.createHeadChaseSteps(body, isBodyAffected, isDangerous, isExistential);
			this.idbNumVariables.put(head.getName(), head.getArguments().size());

			/*update last atom in head*/
			this.lastAtomInHead = head;

			/*update data structures for output sequence*/
			for(String outName : this.outputAtomNames){
				/*it means that the body of the output rule will have this atom*/
				if(this.cSteps.get(outName).intValue()==1 && !this.cLast.containsKey(outName)){
					this.cLast.put(outName, body.get(0).getAtom());
					this.cSteps.put(outName, this.cSteps.get(outName)-1);
				} 
				if(this.cSteps.get(outName).intValue()>1)
					this.cSteps.put(outName, this.cSteps.get(outName)-1);
			}

			/*complete the creation of the rule, adding possible conditions*/
			currentRule = new Rule(head, body, new ArrayList<>());
			if(this.hasSelectionCondition()) {
				currentRule = conditions.addConditions(currentRule);
				this.numberOfSelectionConditions--;
			}

			/*add rule to the model*/
			this.resultModel.readRule(currentRule);
			if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());

			/*update data structure for existentials*/
			if(isExistential && this.firstExistentialHead == null)
				this.firstExistentialHead = new Atom(head.getName(),head.getArguments());


			/*update data structures for output sequence*/
			chaseStepsFinished = true;
			for(String outName : this.outputAtomNames){
				if(this.cSteps.get(outName).intValue()!=0){
					chaseStepsFinished = false;
					break;
				}
			}

			/*update data structures for recursive sequence*/
			if(!isRoot){
				for(String rec : this.indirectRecursionName){
					if(this.rLength.get(rec).intValue()>1)
						this.rLength.put(rec, this.rLength.get(rec)-1);
					if(this.rLength.get(rec).intValue()==1 && !this.rLast.containsKey(rec)){
						this.rLast.put(rec, head);
						if(this.recNonLinearJoinNames.contains(rec) && !this.bodyRuleForIndNonLinRecJoinRightAtom.containsKey(rec))
							this.bodyRuleForIndNonLinRecJoinRightAtom.put(rec, body.get(0).getAtom());
					}

				}
			}

			if(isRoot){
				isRoot = false;
				this.root = currentRule;
			}
		}
	}



	/**
	 * It generates rules for recursive cycles
	 */
	private void generateRulesForRecursions(){

		/*update data structures for recursive sequence*/
		boolean readyForIndirectRecursion = true;
		for(String recName : this.indirectRecursionName){
			if(this.rLength.get(recName).intValue()!=1){
				readyForIndirectRecursion = false;
				break;
			}
		}

		if (log.isDebugEnabled()) log.debug("Generating rules for indirect recursive cycles");
		System.out.println("\n=====Generating rules for indirect recursive cycles=====");
		while(!readyForIndirectRecursion){
			Rule currentRule;

			/*define the BODY of the rule*/
			List<Literal> body = new ArrayList<>();

			/*define whether the rule is linear or join*/	
			String linearOrJoin = this.defineTypeOfRule();

			/*choose the type of join, if needed*/
			this.typeOfJoin = null;
			if(linearOrJoin.equals(ModelGenerator.joinRule))
				this.typeOfJoin = this.defineAndUpdateTypeOfJoin(lastAtomInHead);

			/*build body of current rule*/
			if(linearOrJoin.equals(ModelGenerator.linearRule) || this.typeOfJoin==null){
				LinearRuleGenerator l = new LinearRuleGenerator();
				body.add(l.createLinearBodyRecursiveSteps(this.lastAtomInHead));
				this.numberOfLinearRules--;
			}
			else{
				JoinRuleGenerator j = new JoinRuleGenerator();
				body = j.createJoinBodyRecursiveSteps(this.lastAtomInHead,this.typeOfJoin,this.isGuarded);
				this.numberOfJoinRules--;
			}


			/*define the HEAD of the rule*/
			Atom head;

			/*check whether the body is affected*/
			boolean isBodyAffected = this.affectedAtomNames.contains(body.get(0).getAtom().getName());

			boolean isDangerous = false;
			if(isBodyAffected){
				/*define whether the rule is dangerous, based on typeOfJoin*/
				if(this.typeOfJoin==null)	//linear rule
					isDangerous = this.isDangerousRule();
				else	//join rule
					if(this.typeOfJoin.equals(joinHH) || this.typeOfJoin.equals(joinhhNW))
						isDangerous = false;
					else
						if(this.typeOfJoin.equals(joinhhW))
							isDangerous = true;
						else //joinhH
							isDangerous = this.isDangerousRule();				

				if(isDangerous)
					this.numberOfDangerousRules--;
			}
			/*define whether the rule is existential*/
			boolean isExistential = false;
			if(this.numberOfExistentialRules>0 && !isDangerous){
				isExistential = this.isExistentialRule();
				if(isExistential)
					this.numberOfExistentialRules--;
			}

			/*build head of current rule*/
			LinearRuleGenerator l = new LinearRuleGenerator();
			head = l.createHeadRecursiveSteps(body, isBodyAffected, isDangerous, isExistential);;
			this.idbNumVariables.put(head.getName(), head.getArguments().size());

			/*update last atom in head*/
			this.lastAtomInHead = head;

			/*here we COMPLETE the creation of the rule, adding possible conditions*/
			currentRule = new Rule(head, body, new ArrayList<>());
			if(this.hasSelectionCondition()) {
				currentRule = conditions.addConditions(currentRule);
				this.numberOfSelectionConditions--;
			}

			/*add rule to the model*/
			this.resultModel.readRule(currentRule);
			if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());


			/*update data structures for recursive sequence*/
			for(String rec : this.indirectRecursionName){
				if(this.rLength.get(rec).intValue()>1)
					this.rLength.put(rec, this.rLength.get(rec)-1);
				if(this.rLength.get(rec).intValue()==1 && !this.rLast.containsKey(rec)){
					this.rLast.put(rec, head);
					/*if it is non linear, update corresponding map to remember it*/
					if(this.recNonLinearJoinNames.contains(rec) && !this.bodyRuleForIndNonLinRecJoinRightAtom.containsKey(rec))
						this.bodyRuleForIndNonLinRecJoinRightAtom.put(rec, body.get(0).getAtom());
				}	
			}

			/*update data structure for existentials*/
			if(isExistential && this.firstExistentialHead == null)
				this.firstExistentialHead = new Atom(head.getName(),head.getArguments());

			readyForIndirectRecursion = true;
			for(String recName : this.indirectRecursionName){
				if(this.rLength.get(recName).intValue()!=1){
					readyForIndirectRecursion = false;
					break;
				}
			}
		}


		if (log.isDebugEnabled()) log.debug("Generating rules for indirect recursive closure");
		System.out.println("\n=====Generating rules for indirect recursive closure=====");
		for(String recName : this.indirectRecursionName){

			Atom rLast = this.rLast.get(recName);

			Rule currentRule;
			/*whether the rule has a right recursive join*/
			boolean isRightRecJoin = false;

			/*define the BODY of the rule*/
			List<Literal> body = new ArrayList<>();

			/*choose the type of join, if needed*/
			this.typeOfJoin = null;
			if(!this.recLinNames.contains(recName))
				this.typeOfJoin = this.defineAndUpdateTypeOfJoin(lastAtomInHead);

			/*build body of current rule*/
			if(this.recLinNames.contains(recName) || this.typeOfJoin==null){
				LinearRuleGenerator l = new LinearRuleGenerator();
				body.add(l.createLinearBodyIndirectRecursiveClosure(rLast));
				this.numberOfLinearRules--;
			}
			else{
				JoinRuleGenerator j = new JoinRuleGenerator();
				/*choose the type of recursive join*/
				String typeOfRecJoin;
				if(this.recLeftJoinNames.contains(recName))
					typeOfRecJoin = "leftRecJoin";
				else
					if(this.recRightJoinNames.contains(recName)) {
						typeOfRecJoin = "rightRecJoin";
						isRightRecJoin = true;
					}
					else
						typeOfRecJoin = "nonLinearRecJoin";

				body = j.createJoinBodyIndirectRecursiveClosure(rLast,this.typeOfJoin,typeOfRecJoin,recName,this.isGuarded);//,harmlessOrDangerous
				this.numberOfJoinRules--;
			}


			/*define the HEAD of the rule*/
			Atom head;

			/*check whether the body is affected*/
			boolean isBodyAffected;
			if(isRightRecJoin)
				isBodyAffected = this.affectedAtomNames.contains(body.get(1).getAtom().getName());
			else
				isBodyAffected = this.affectedAtomNames.contains(body.get(0).getAtom().getName());

			/*build head of current rule*/
			RuleGenerator l = new LinearRuleGenerator();
			head = l.createHeadIndirectRecursiveClosure(body, this.root.getHead().get(0), isBodyAffected, isRightRecJoin);


			/*complete the creation of the rule, adding possible conditions*/
			currentRule = new Rule(head, body, new ArrayList<>());
			if(this.hasSelectionCondition()) {
				currentRule = conditions.addConditions(currentRule);
				this.numberOfSelectionConditions--;
			}

			/*add rule to the model*/
			this.resultModel.readRule(currentRule);
			if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
		}



		if (log.isDebugEnabled()) log.debug("Generating rules for direct recursive closure");
		System.out.println("\n=====Generating rules for direct recursive closure=====");
		for(String recName : this.directRecursionName){

			Rule currentRule;
			/*whether the rule has a right recursive join*/
			boolean isRightRecJoin = false;

			/*define the BODY of the rule*/
			List<Literal> body = new ArrayList<>();

			/*choose the type of join, if needed*/
			this.typeOfJoin = null;
			if(!this.recLinNames.contains(recName))
				this.typeOfJoin = this.defineAndUpdateTypeOfJoin(lastAtomInHead);

			/*build body of current rule*/
			if(this.recLinNames.contains(recName) || this.typeOfJoin==null){
				LinearRuleGenerator l = new LinearRuleGenerator();
				body.add(l.createLinearBodyDirectRecursiveClosure());
				this.numberOfLinearRules--;
			}
			else{
				JoinRuleGenerator j = new JoinRuleGenerator();
				/*choose the type of recursive join*/
				String typeOfRecJoin;
				if(this.recLeftJoinNames.contains(recName))
					typeOfRecJoin = "leftRecJoin";
				else
					if(this.recRightJoinNames.contains(recName)) { 
						typeOfRecJoin = "rightRecJoin";
						isRightRecJoin = true;
					}
					else
						typeOfRecJoin = "nonLinearRecJoin";

				body = j.createJoinBodyDirectRecursiveClosure(this.typeOfJoin,typeOfRecJoin,recName,this.isGuarded);
				this.numberOfJoinRules--;
			}


			/*define the HEAD of the rule*/
			Atom head;

			/*check whether the body is affected*/
			boolean isBodyAffected;
			if(isRightRecJoin)
				isBodyAffected = this.affectedAtomNames.contains(body.get(1).getAtom().getName());
			else
				isBodyAffected = this.affectedAtomNames.contains(body.get(0).getAtom().getName());

			/*build head of current rule*/
			LinearRuleGenerator l = new LinearRuleGenerator();
			head = l.createHeadDirectRecursiveClosure(this.literalDirectRec.getAtom(), isBodyAffected);


			/*complete the creation of the rule, adding possible conditions*/
			currentRule = new Rule(head, body, new ArrayList<>());
			if(this.hasSelectionCondition()) {
				currentRule = conditions.addConditions(currentRule);
				this.numberOfSelectionConditions--;
			}

			/*add rule to the model*/
			this.resultModel.readRule(currentRule);
			if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
		}



		if (log.isDebugEnabled()) log.debug("Generating rules for indirect non-linear recursion link to main program");
		System.out.println("\n=====Generating rules for indirect non-linear recursion link to main program=====");
		for(String recNonLinName : this.bodyRuleForIndNonLinRecJoinRightAtom.keySet()){

			Atom rightAtomInNonLinRecJoin = this.recNonLinIndJoinRightAtom.get(recNonLinName);
			if(rightAtomInNonLinRecJoin!=null) {
				Atom bodyForRightAtomInNonLinRecJoin = this.bodyRuleForIndNonLinRecJoinRightAtom.get(recNonLinName);
				Rule currentRule;
				/*whether the rule has a right recursive join*/
				boolean isRightRecJoin = false;

				/*define the BODY of the rule*/
				List<Literal> body = new ArrayList<>();
				LinearRuleGenerator l = new LinearRuleGenerator();
				body.add(l.createLinearBodyChaseSteps(bodyForRightAtomInNonLinRecJoin, false));
				this.numberOfLinearRules--;

				/*define the HEAD of the linear rule*/
				Atom head;
				/*check whether the body is affected*/
				boolean isBodyAffected = this.affectedAtomNames.contains(body.get(0).getAtom().getName());

				/*build head of current rule*/
				l = new LinearRuleGenerator();
				head = l.createHeadIndirectRecursiveClosure(body, rightAtomInNonLinRecJoin, isBodyAffected, isRightRecJoin);

				/*complete the creation of the rule, adding possible conditions*/
				currentRule = new Rule(head, body, new ArrayList<>());
				if(this.hasSelectionCondition()) {
					currentRule = conditions.addConditions(currentRule);
					this.numberOfSelectionConditions--;
				}

				/*add rule to the model*/
				this.resultModel.readRule(currentRule);
				if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
			}
		}
	}



	/**
	 * It generates rules to satisfy remaining input requirements
	 */
	private void generateRulesForCompletion() {

		if (log.isDebugEnabled()) log.debug("Generating rules for program completion");
		System.out.println("\n=====Generating rules for program completion=====");

		/*whether this is the first rule in this sequence*/
		boolean isNewRuleAfterRoot = true;

		/*generate remaining non existential, non dangerous linear rules in secondary branch of the program*/
		while((this.numberOfLinearRules-this.numberOfExistentialRules-this.numberOfDangerousRules-this.numberOfOutputAtoms)>0){
			Rule currentRule;

			/*define the BODY of the rule*/
			List<Literal> body = new ArrayList<>();
			/*get last atom in previous head*/
			Atom lastAtomInHead;
			if(isNewRuleAfterRoot)
				lastAtomInHead = this.root.getHead().get(0);
			else
				lastAtomInHead = this.lastAtomInHead;

			/*build body of current rule*/
			LinearRuleGenerator l = new LinearRuleGenerator();
			body.add(l.createLinearBodySecondaryRule(lastAtomInHead));
			this.numberOfLinearRules--;

			if(isNewRuleAfterRoot)
				isNewRuleAfterRoot = false;

			/*define the HEAD of the rule*/				
			Atom head = l.createHeadSecondaryRule(body);
			this.idbNumVariables.put(head.getName(), head.getArguments().size());

			/*update last atom in head*/
			this.lastAtomInHead = head;		

			/*complete the creation of the rule, adding possible conditions*/
			currentRule = new Rule(head, body, new ArrayList<>());
			if(this.hasSelectionCondition()) {
				currentRule = conditions.addConditions(currentRule);
				this.numberOfSelectionConditions--;
			}

			/*add rule to the model*/
			this.resultModel.readRule(currentRule);
			if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
		}


		/*generate remaining rules in tertiary branches of the program*/

		/*if there is at least one existential rule in the main program*/
		if(this.firstExistentialHead != null) {

			/*generate remaining existential rules*/
			while(this.numberOfExistentialRules>0){
				Rule currentRule;

				/*define the BODY of the linear rule*/
				List<Literal> body = new ArrayList<>();
				LinearRuleGenerator l = new LinearRuleGenerator();	
				body.add(l.createLinearBodyTertiaryRule(this.firstExistentialHead));
				this.numberOfLinearRules--;

				/*define the HEAD of the linear rule*/
				Atom head = l.createHeadTertiaryRule(body, true, false, true);
				this.numberOfExistentialRules--;

				/*complete the creation of the linear rule, adding possible conditions*/
				currentRule = new Rule(head, body, new ArrayList<>());
				if(this.numberOfSelectionConditions>0) {
					currentRule = conditions.addConditions(currentRule);
					this.numberOfSelectionConditions--;
				}

				/*add rule to the model*/
				this.resultModel.readRule(currentRule);
				if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
			}


			/*generate remaining dangerous rules*/
			while(this.numberOfDangerousRules>0){
				Rule currentRule;

				/*define the BODY of the linear rule*/
				List<Literal> body = new ArrayList<>();
				LinearRuleGenerator l = new LinearRuleGenerator();	
				body.add(l.createLinearBodyTertiaryRule(this.firstExistentialHead));
				this.numberOfLinearRules--;

				/*define the HEAD of the linear rule*/
				Atom head = l.createHeadTertiaryRule(body, true, true, false);
				this.numberOfDangerousRules--;

				/*complete the creation of the linear rule, adding possible conditions*/
				currentRule = new Rule(head, body, new ArrayList<>());
				if(this.numberOfSelectionConditions>0) {
					currentRule = conditions.addConditions(currentRule);
					this.numberOfSelectionConditions--;
				}

				/*add rule to the model*/
				this.resultModel.readRule(currentRule);
				if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
			}

			
			/*generate remaining harmless-harmless join rules with ward*/
			while(this.numberOfHarmlessHarmlessJoinsWithWard>0) {
				Rule currentRule;

				/*define the BODY of the rule*/
				List<Literal> body = new ArrayList<>();

				/*build body of current rule*/
				JoinRuleGenerator j = new JoinRuleGenerator();
				body = j.createJoinBodyTertiaryRule(this.firstExistentialHead,joinhhW,this.isGuarded);
				this.numberOfJoinRules--;
				this.numberOfHarmlessHarmlessJoinsWithWard--;

				/*define the HEAD of the linear rule*/
				Atom head = j.createHeadTertiaryRule(body, true, false, false);

				/*complete the creation of the join rule, adding possible conditions*/
				currentRule = new Rule(head, body, new ArrayList<>());
				if(this.numberOfSelectionConditions>0) {
					currentRule = conditions.addConditions(currentRule);
					this.numberOfSelectionConditions--;
				}

				/*add rule to the model*/
				this.resultModel.readRule(currentRule);
				if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
			}
			

			/*generate remaining harmless-harmful join rules*/
			while(this.numberOfHarmlessHarmfulJoins>0) {
				Rule currentRule;

				/*define the BODY of the rule*/
				List<Literal> body = new ArrayList<>();

				/*build body of current rule*/
				JoinRuleGenerator j = new JoinRuleGenerator();
				body = j.createJoinBodyTertiaryRule(this.firstExistentialHead,joinhH,this.isGuarded);
				this.numberOfJoinRules--;
				this.numberOfHarmlessHarmfulJoins--;

				/*define the HEAD of the linear rule*/
				Atom head = j.createHeadTertiaryRule(body, true, false, false);

				/*complete the creation of the join rule, adding possible conditions*/
				currentRule = new Rule(head, body, new ArrayList<>());
				if(this.numberOfSelectionConditions>0) {
					currentRule = conditions.addConditions(currentRule);
					this.numberOfSelectionConditions--;
				}

				/*add rule to the model*/
				this.resultModel.readRule(currentRule);
				if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
			}
			
			
			/*generate remaining harmful-harmful join rules*/
			while(this.numberOfHarmfulHarmfulJoins>0) {
				Rule currentRule;

				/*define the BODY of the rule*/
				List<Literal> body = new ArrayList<>();

				/*build body of current rule*/
				JoinRuleGenerator j = new JoinRuleGenerator();
				body = j.createJoinBodyTertiaryRule(this.firstExistentialHead,joinHH,this.isGuarded);
				this.numberOfJoinRules--;
				this.numberOfHarmfulHarmfulJoins--;

				/*define the HEAD of the linear rule*/
				Atom head = j.createHeadTertiaryRule(body, true, false, false);

				/*complete the creation of the join rule, adding possible conditions*/
				currentRule = new Rule(head, body, new ArrayList<>());
				if(this.numberOfSelectionConditions>0) {
					currentRule = conditions.addConditions(currentRule);
					this.numberOfSelectionConditions--;
				}

				/*add rule to the model*/
				this.resultModel.readRule(currentRule);
				if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
			}
		}


		/*generate remaining harmless-harmless join rules without ward, also if the other types could not be created*/
		while(this.numberOfJoinRules>0) {
			Rule currentRule;

			/*define the BODY of the rule*/
			List<Literal> body = new ArrayList<>();

			/*build body of current rule*/
			JoinRuleGenerator j = new JoinRuleGenerator();
			body = j.createJoinBodyTertiaryRule(this.root.getBody().get(0).getAtom(),joinhhNW,this.isGuarded);
			this.numberOfJoinRules--;
			this.numberOfHarmlessHarmlessJoinsWithoutWard--;

			/*define the HEAD of the linear rule*/
			Atom head = j.createHeadTertiaryRule(body, false, false, false);

			/*complete the creation of the join rule, adding possible conditions*/
			currentRule = new Rule(head, body, new ArrayList<>());
			if(this.numberOfSelectionConditions>0) {
				currentRule = conditions.addConditions(currentRule);
				this.numberOfSelectionConditions--;
			}

			/*add rule to the model*/
			this.resultModel.readRule(currentRule);
			if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
		}
	}



	/**
	 * It generates rules to complete input-output sequence
	 */
	private void generateRulesForOutput(){

		if (log.isDebugEnabled()) log.debug("Generating rules for input-output sequence closure");
		System.out.println("\n=====Generating rules for input-output sequence closure=====");
		for(String outputAtomName : this.outputAtomNames) {
			Rule currentRule;
			OutputAnnotation outputAnnot;

			/*define the BODY of the linear rule*/
			List<Literal> body = new ArrayList<>();
			LinearRuleGenerator l = new LinearRuleGenerator();
			body.add(l.createLinearBodyOutputRule(this.cLast.get(outputAtomName)));
			this.numberOfLinearRules--;

			/*define the HEAD of the linear rule*/
			boolean isBodyAffected = this.affectedAtomNames.contains(body.get(0).getAtom().getName());
			boolean isDangerous = false;
			if(this.numberOfDangerousRules>0 && isBodyAffected){
				isDangerous = true;
				this.numberOfDangerousRules--;
			}
			/*define whether the rule is existential*/
			boolean isExistential = false;
			if(this.numberOfExistentialRules>0 && !isDangerous){
				isExistential = true;
				this.numberOfExistentialRules--;
			}
			Atom head = l.createHeadOutputRule(body, outputAtomName, isBodyAffected, isDangerous, isExistential);

			/*complete the creation of the linear rule, adding possible conditions*/
			currentRule = new Rule(head, body, new ArrayList<>());
			if(this.numberOfSelectionConditions>0) {
				currentRule = conditions.addConditions(currentRule);
				this.numberOfSelectionConditions--;
			}

			/*add rule to the model*/
			this.resultModel.readRule(currentRule);
			if (log.isDebugEnabled()) log.debug("Generated rule: " + currentRule.toString());
			outputAnnot = new OutputAnnotation(outputAtomName);
			this.resultModel.readAnnotation(outputAnnot);
		}

	}


}
